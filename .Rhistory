fts_x[,2]
plot( fts_x[,1], type='l' )
vs
print(n)
# get Vs
vs <- matrix(0, n_grid, t_max)
for (n in (1:n_pc)){
print(n)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e, exp_f )
for (ii in 1:(t_half+1)){
# split by if we're at zero freq or not
if (ii == t_half + 1){
# this ii corresponds to t_max = zero frequency
# do nothing
} else {
# all the other ii, going from 1 to t_half
# function
omega <- (2*ii*pi)/t_max
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) inner_product_e_f * exp_f
vs[,ii] <- vs[,ii] + sigma_l_sqrt * phi * zs[n,ii]
}
}
}
for (n in (1:n_pc)){
print(n)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e, exp_f )
for (ii in 1:(t_half+1)){
# split by if we're at zero freq or not
if (ii == t_half + 1){
# this ii corresponds to t_max = zero frequency
# do nothing
} else {
# all the other ii, going from 1 to t_half
# function
omega <- (2*ii*pi)/t_max
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) inner_product_e_f * exp_f
vs[,ii] <- vs[,ii] + sigma_l_sqrt * phi * zs[n,ii]
}
}
}
# get Vs
vs <- matrix(0, n_grid, t_max)
for (n in (1:n_pc)){
print(n)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e, exp_f )
for (ii in 1:(t_half+1)){
# split by if we're at zero freq or not
if (ii == t_half + 1){
# this ii corresponds to t_max = zero frequency
# do nothing
} else {
# all the other ii, going from 1 to t_half
# function
omega <- (2*ii*pi)/t_max
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * inner_product_e_f * exp_f
vs[,ii] <- vs[,ii] + sigma_l_sqrt * phi * zs[n,ii]
}
}
}
# get Vs
vs <- matrix(0, n_grid, t_max)
for (n in (1:n_pc)){
print(n)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e * exp_f )
for (ii in 1:(t_half+1)){
# split by if we're at zero freq or not
if (ii == t_half + 1){
# this ii corresponds to t_max = zero frequency
# do nothing
} else {
# all the other ii, going from 1 to t_half
# function
omega <- (2*ii*pi)/t_max
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * inner_product_e_f * exp_f
vs[,ii] <- vs[,ii] + sigma_l_sqrt * phi * zs[n,ii]
}
}
}
# simulate FARIMA(d,1,0) like Li et al. (2019)
# (I-\Lambda)^d X_t = Z_t
# Z_t is ARMA(1,0) process with
# .... autoregressive operator A(x,y) = 0.34 exp( -(x^2+y^2)/2 )
# .... covariance operator of the error Sigma(x,y) = min(x,y) ... i.e. Brownian motion
############################################
## simulation setting
t_max <- 16 # length of simulation
n_grid <- 11 # spatial resolution
grid <- seq( 0, 1, length.out = n_grid ) # grid of [0,1] interval
n_pc <- 3 # number of eigenfunctions of Sigma to use
##########################################
## get variables Z
# prepare the ts I'm generating
t_half <- ceiling(t_max/2)
t_max <- t_half*2
ts <- c(1:t_half, t_max)
# remember, t_half and t_max are real
zs <- matrix(0, n_pc, t_half+1 )
# complex zs
for (ii in 1:(t_half-1)){
zs[,ii] <- rnorm(n_pc) + 1i * rnorm(n_pc) # complex number, independent real and imag parts, variance 1 each part
}
# real zs
zs[,t_half] <- 2*rnorm(n_pc)
zs[,t_half+1] <- 2*rnorm(n_pc)
##########################################
## get variables V
# prepare quantities for calculation of basis functions
exp_f <- exp( -grid^2 / 2 )
exp_f_norm2 <- mean( exp_f^2 ) # square of L2 integral norm
# get Vs
vs <- matrix(0, n_grid, t_max)
for (n in (1:n_pc)){
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e * exp_f )
for (ii in 1:(t_half+1)){
# split by if we're at zero freq or not
if (ii == t_half + 1){
# this ii corresponds to t_max = zero frequency
# do nothing
} else {
# all the other ii, going from 1 to t_half
# function
omega <- (2*ii*pi)/t_max
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * inner_product_e_f * exp_f
vs[,ii] <- vs[,ii] + sigma_l_sqrt * phi * zs[n,ii]
}
}
}
# mirror Vs t_half+1,...,t_max-1
for (ii in 1:(t_half-1)){
vs[,t_max-ii] <- Conj(vs[,ii])
}
#########################################
## iFFT to temporal domain
# rearange the array so zero freq is at the beginning - that's what iFFT needs
vs_for_ifft <- matrix(0, n_grid, t_max)
vs_for_ifft[,2:t_max] <- vs[,1:(t_max-1)]
vs_for_ifft[,1] <- vs[,t_max] # zero freq
fts_x = sqrt(pi*t_max) * mvfft( vs_for_ifft, inverse = T )
#########################################
## visualise
fts_x[,2]
plot( fts_x[,1], type='l' )
fts_x[,1]
fts_x[,2]
vs_for_ifft
fts_x = sqrt(pi*t_max) * t(mvfft( t(vs_for_ifft), inverse = T ))
fts_x[,2]
plot( fts_x[,1], type='l' )
plot( real(fts_x[,1]), type='l' )
plot( re(fts_x[,1]), type='l' )
plot( Re(fts_x[,1]), type='l' )
library(plotly)
install.packages("plotly")
library(plotly)
# volcano is a numeric matrix that ships with R
fig <- plot_ly(z = ~volcano)
fig <- fig %>% add_surface()
fig
library(plotly)
# volcano is a numeric matrix that ships with R
fig <- plot_ly(z = ~volcano)
fig <- fig %>% add_surface()
fig
library(plotly)
# volcano is a numeric matrix that ships with R
fig <- plot_ly(z = ~volcano)
fig <- fig %>% add_surface()
fig
fts_x[,2]
fts_x = sqrt(pi*t_max) * Re(t(mvfft( t(vs_for_ifft), inverse = T )))
#########################################
## visualise
fts_x[,2]
plot( Re(fts_x[,1]), type='l' )
fts_x[,2]
plot( fts_x[,1], type='l' )
persp( fts_x )
heatmap( fts_x )
# Library
library(plotly)
# Data: volcano is provided by plotly
# Plot
p <- plot_ly(z = volcano, type = "surface")
p
# Library
library(plotly)
# Data: volcano is provided by plotly
# Plot
p <- plot_ly(z = volcano, type = "surface")
p
install.packages("plotly")
# Library
library(plotly)
# Data: volcano is provided by plotly
# Plot
p <- plot_ly(z = volcano, type = "surface")
p
#install.packages("plotly")
# Library
library(plotly)
# Data: volcano is provided by plotly
# Plot
p <- plot_ly(z = volcano, type = "surface")
p
heatmap( fts_x )
plot( fts_x[,1], type='l' )
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
phi %*% t(phi)
install.packages("sde")
start_time = Sys.time()
m <- phi %*% t(phi)
end_time  = Sys.time()
end_time - start_time
start_time = Sys.time()
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
end_time  = Sys.time()
end_time - start_time
n_grid_freq = 10
n_grid <- 1001 # spatial resolution
grid <- seq( 0, 1, length.out = n_grid ) # grid of [0,1] interval
n_pc = 3
lag = 0
start_time = Sys.time()
# where shall I save the cov lag h kernel
covlagh = matrix(0, nrow=n_grid, ncol=n_grid)
# prepare quantities for calculation of basis functions
exp_f <- exp( -grid^2 / 2 )
exp_f_norm2 <- mean( exp_f^2 ) # square of L2 integral norm
# integrate the spectral density
pb <- txtProgressBar(style = 3)
for (n in (1:n_pc)){
setTxtProgressBar(pb, n/n_pc)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e * exp_f )
for (ii in (1:n_grid_freq)){
# function
omega <- (2*ii*pi)/n_grid_freq
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * inner_product_e_f * exp_f
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
}
}
close(pb)
end_time  = Sys.time()
end_time - start_time
n_grid_freq = 1000
n_grid <- 11 # spatial resolution
grid <- seq( 0, 1, length.out = n_grid ) # grid of [0,1] interval
n_pc = 3
lag = 0
start_time = Sys.time()
# where shall I save the cov lag h kernel
covlagh = matrix(0, nrow=n_grid, ncol=n_grid)
# prepare quantities for calculation of basis functions
exp_f <- exp( -grid^2 / 2 )
exp_f_norm2 <- mean( exp_f^2 ) # square of L2 integral norm
# integrate the spectral density
pb <- txtProgressBar(style = 3)
for (n in (1:n_pc)){
setTxtProgressBar(pb, n/n_pc)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e * exp_f )
for (ii in (1:n_grid_freq)){
# function
omega <- (2*ii*pi)/n_grid_freq
phi <- sigma_e + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * inner_product_e_f * exp_f
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
}
}
close(pb)
end_time  = Sys.time()
end_time - start_time
start_time = Sys.time()
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
end_time  = Sys.time()
end_time - start_time
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
start_time = Sys.time()
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
end_time  = Sys.time()
end_time - start_time
phi %*% t(phi)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
sigma_e %*% Conj(sigma_e)
sigma_e
t(sigma_e)
covlagh <- covlagh + sigma_l_sqrt^2 * exp_f %o% Conj(exp_f) * integral_3
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
sigma_e %o% Conj(t(sigma_e))
m=sigma_e %o% Conj(sigma_e)
m=sigma_e %o% sigma_e
size(m)
shape(m)
dim(m)
n_grid_freq = 10
n_grid <- 1001 # spatial resolution
grid <- seq( 0, 1, length.out = n_grid ) # grid of [0,1] interval
n_pc = 3
lag = 0
start_time = Sys.time()
# where shall I save the cov lag h kernel
covlagh = matrix(0, nrow=n_grid, ncol=n_grid)
# prepare quantities for calculation of basis functions
exp_f <- exp( -grid^2 / 2 )
exp_f_norm2 <- mean( exp_f^2 ) # square of L2 integral norm
# integrate the spectral density
pb <- txtProgressBar(style = 3)
for (n in (1:n_pc)){
setTxtProgressBar(pb, n/n_pc)
# prepare eigenvalue and eigenfunction of Sigma
sigma_l_sqrt <- 1/((n-0.5)*pi)
sigma_e <- sqrt(2) * sin( (n-0.5)*pi*grid )
inner_product_e_f <- mean( sigma_e * exp_f )
# save only the scalar integrals
integral_1 <- 0
integral_2 <- 0
integral_3 <- 0
for (ii in (1:n_grid_freq)){
# function
omega <- (2*ii*pi)/n_grid_freq
integral_1 <- integral_1 + ( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ) * (2*pi)/n_grid_freq
}
integral_1 <- integral_1 * inner_product_e_f * (2*pi)/n_grid_freq
integral_2 <- Conj(integral_1)
integral_3 <- integral_1 * integral_2
covlagh <-           sigma_l_sqrt^2 * sigma_e %o% Conj(sigma_e) * 2*pi
covlagh <- covlagh + sigma_l_sqrt^2 * exp_f %o% Conj(sigma_e) * integral_1
covlagh <- covlagh + sigma_l_sqrt^2 * sigma_e %o% Conj(exp_f) * integral_2
covlagh <- covlagh + sigma_l_sqrt^2 * exp_f %o% Conj(exp_f) * integral_3
}
close(pb)
end_time  = Sys.time()
end_time - start_time
#persp(Re(covlagh))
image(Re(covlagh))
## timing
start_time = Sys.time()
covlagh <- covlagh + sigma_l_sqrt^2 * phi %*% t(phi) * exp(+1i*omega*lag) * (2*pi)/n_grid_freq
end_time  = Sys.time()
end_time - start_time
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
persp(Re(covlagh))
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
image(Re(covlagh))
persp(Re(covlagh))
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
image(Re(covlagh))
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
covlagh <- covlagh + sigma_l_sqrt^2 * exp_f %o% (exp_f) * integral_4
lag = 0
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
integral_4 <- integral_4 + abs(( exp(-1i*omega) *0.34 )/( 1- exp(-1i*omega)*0.34*exp_f_norm2 ))^2 * exp(1i*omega*lag)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/precalculate_lagh_cov.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
repmat(1, 3)
kronecker(grid^2,matrix(1,1,n_grid))
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/naive_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/naive_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/naive_lagh_cov.R', echo=TRUE)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/naive_lagh_cov.R', echo=TRUE)
0:10
kronecker()
covlag0 = matrix(0, n_grid, n_grid)
sigma <- min( grid_matrix, t(grid_matrix) )
sigma <- min( grid_matrix, t(grid_matrix) )
sigma_scaled <- sigma / n_grid
image(sigma)
sigma <- pmin( grid_matrix, t(grid_matrix) )
sigma_scaled <- sigma / n_grid
image(sigma)
source('C:/C-epfl results/Code _ Simulation of FTS/R/simulate like Li et al/naive_lagh_cov.R', echo=TRUE)
persp(ar_op)
persp(covlag0)
persp(ar_op)
persp(sigma)
persp(sigma)
image(sigma)
sigma
args=c("a","bbb","cccccccc")
print(args)
fts_x
size(fts_x)
shape(fts_x)
dim(fts_x)
t_max=200
n_grid=101
sigma <- function(x,y) { 1/(2*pi) * pmin(x,y)}
# define filtration
fractional_d <- 0.2
theta <- function(omega,f){
( 2 * sin(omega/2) )^(-fractional_d) *
(f + (exp(-1i*omega)*0.34) /(1-exp(-1i*omega)*0.34*sqrt(pi)/2*erfi(1)) *
rank_one_tensor( function(x){exp((x^2)/2)}, function(x){exp((x^2)/2)}, f ))
}
fts_x <- f_filtration_simulate(sigma, theta, t_max, n_grid, seed_number=seed_number, sigma_svd = f_BM_SVD(n_grid))
source('C:/Users/tomas/Dropbox/Simulation FTS - v2/functions_simstudy.R', echo=TRUE)
source('C:/Users/tomas/Dropbox/Simulation FTS - v2/functions_custom_filtration.R', echo=TRUE)
fts_x <- f_filtration_simulate(sigma, theta, t_max, n_grid, seed_number=seed_number, sigma_svd = f_BM_SVD(n_grid))
seed_number=1
fts_x <- f_filtration_simulate(sigma, theta, t_max, n_grid, seed_number=seed_number, sigma_svd = f_BM_SVD(n_grid))
library(pracma)
fts_x <- f_filtration_simulate(sigma, theta, t_max, n_grid, seed_number=seed_number, sigma_svd = f_BM_SVD(n_grid))
# AR part
operators_ar <- list(  function(x,y){ -0.34 * exp(+(x^2+y^2)/2) })
fts_x <- f_apply_AR_part(fts_x, operators_ar)
fts_x <- fts_x[,101:end]
fts_x <- fts_x[,101:]
nrow(fts_x)
fts_x <- fts_x[,101:ncol(fts_x)]
source('~/GitHub/specsimfts/demo/demo_custom_filtration_SVD.R', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/GitHub/specsimfts/demo/demo_custom_filtration_SVD.R', echo=TRUE)
source('~/GitHub/specsimfts/demo/demo_custom_filtration_SVD.R', echo=TRUE)
source('~/GitHub/specsimfts/demo/demo_FARFIMA_spec_vs_hybrid.R', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/GitHub/specsimfts/demo/demo_FARFIMA_spec_vs_hybrid.R', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/GitHub/specsimfts/demo/demo_FARFIMA_as_filtration.R', echo=TRUE)
source('~/GitHub/specsimfts/demo/demo_custom_filtration_SVD.R', echo=TRUE)
source('~/GitHub/specsimfts/demo/demo_custom_filtration.R', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/GitHub/specsimfts/demo/demo_custom_filtration.R', echo=TRUE)
source('~/GitHub/specsimfts/demo/demo_custom_filtration_SVD.R', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library(roxygen2); # Read in the roxygen2 R package
roxygenise();      # Builds the help files
setwd("C:/Users/tomas/OneDrive/Documents/GitHub/specsimfts")
library(devtools);
load_all(".");
?FARFIMA_simulate
library(roxygen2); # Read in the roxygen2 R package
roxygenise();      # Builds the help files
library("specsimfts")
demo("demo_FARFIMA_as_filtration")
?filtration_covlagh_operator
# Define the spectral density operator as an integral operator with kernel
k_bbridge <- function(x,y) { pmin(x,y)-x*y }
spec_density <- function( omega, x,y ){ 1/(1-0.9 *cos(omega)) * k_bbridge( (x-omega/pi)%%1, (y-omega/pi)%%1  ) }
# evaluation setting
lag <- 1 # change here to evaluate different lag-h autocovariance operator. put "lag <- 0" for lag-0 covariance operator
n_grid <- 101
# calculate the lag-h autocovariance operator
covlagh <- spec_density_covlagh_operator(spec_density, lag, n_grid)
# visualise as a surface plot
persp(covlagh)

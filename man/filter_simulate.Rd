% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_simulate.R
\name{filter_simulate}
\alias{filter_simulate}
\title{Simulate a FTS defined as a filter of a white noise}
\usage{
filter_simulate(
  theta,
  t_max,
  n_grid,
  n_pc = n_grid,
  seed_number = NULL,
  sigma = NULL,
  sigma_eigenvalues = NULL,
  sigma_eigenfunctions = NULL,
  include_zero_freq = F
)
}
\arguments{
\item{theta}{The frequency response operator Theta(omega) of the filter used for the definition of filtered white noise. A function of two variables, \code{omega} and \code{f}, where \code{f} is a vector (discretisation of a function) on which the operator Theta at frequency \code{omega} is applied onto. See the example bellow to inspect how you can define Theta(omega). The functions \code{\link{rank_one_tensor}} and \code{\link{kernel_operator}} might be useful for the definition of Theta. Must be well defined for frequencies (0,pi]. The interval [pi,2pi) is not used and is calculated by mirroring of (0,pi].}

\item{t_max}{Time horizon to be simulated. Must be an even number, otherwise it is increased by one.}

\item{n_grid}{Number of grid points (spatial resolution) of the discretisation of [0,1] where the FTS is to be simulated.}

\item{n_pc}{The number of eigenfunctions of sigma to be used for the simulation. Setting n_pc=n_grid is recommended as there is hardly any computational gain when n_pc is smaller. In case the sigma is defined as finite rank operator (through lists \code{sigma_eigenvalues} and \code{sigma_eigenfunctions}) and \code{n_pc} is higher than this finite rank, \code{n_pc} is automatically discresed to match this finite rank.}

\item{seed_number}{The random seed inicialization for the simulation. The value \code{NULL} means no inicialization}

\item{sigma}{The covariance operator of the white noise innovation. A function of two variables, \code{x} and \code{y}, returns the value of the covariance kernel evaluated at (\code{x},\code{y}).}

\item{sigma_eigenvalues}{Alternatively, you can define the white noise innovation covariance operator through its eigendecomposition, in which case supply the arguments \code{sigma_eigenvalues} and \code{sigma_eigenfunctions} but leave out \code{sigma} (or set it \code{NULL}). The eigendecomposition can be defined either as (i) a list of finite number of eigenvalues/eigenfunctions, or (ii) a function returning the eigenvalue/eigenfunction of given order. In the case (i), the \code{sigma_eigenvalues} parameter is simply a vector of eigenvalues. In the case (ii), the \code{sigma_eigenvalues} parameter is a function of the variable \code{n} which returns the \code{n}-th eigenvalue. See the example bellow for the implementation of the two cases.}

\item{sigma_eigenfunctions}{See \code{sigma_eigenvalues} before. In the case (i), the \code{sigma_eigenfunctions} parameter is a list of functions with the same length as the parameter \code{sigma_eigenvalues}. Each function is a function of the variable \code{x} that returns the value of the eigenfunction at point \code{x}. The order of the functions in the list determine the order of eigenfunctions. In the case (ii), the \code{sigma_eigenfunctions} parameter is a function of two variables, \code{n} and \code{x}, that returns the value of the \code{n}-th eigenfunction at the point \code{x}.}

\item{include_freq_zero}{If set \code{TRUE}, the zero frequency is included for simulation in the spectral domain. Set \code{FALSE} for processes with singularity at frequency zero, e.g. the long-range dependent FARFIMA(p,d,q) process.}
}
\value{
functional time series sample, matrix of size (\code{n_grid},\code{t_max})
}
\description{
Simulate functional time series sample when the dynamics is defined as a filtered white noise through the white noise covariance operator and the filter is given by its frequency response function Theta.
}
\examples{
# define the white noise covariance operator (Brownian motion)
sigma <- function(x,y) { pmin(x,y) }

# # Alternatively defined the sigma covariance through its eigendecomposition, and supply it to the function 'filter_simulate'
# sigma_eigenvalues <- function(n) { 1/((n-0.5)*pi)^2 }
# sigma_eigenfunctions <- function(n,x) { sqrt(2)*sin((n-0.5)*pi*x) }

# # Alternatively, define the innovation covariance as low-rank (through a list)
# sigma_eigenvalues <- c(1, 0.6, 0.3, 0.1, 0.1, 0.1, 0.05, 0.05, 0.05, 0.05)
# sigma_eigenfunctions <- list(
#   function(x){ sin(2*pi*x) },
#   function(x){ cos(2*pi*x) },
#   function(x){ sin(4*pi*x) },
#   function(x){ cos(4*pi*x) },
#   function(x){ sin(6*pi*x) },
#   function(x){ cos(6*pi*x) },
#   function(x){ sin(8*pi*x) },
#   function(x){ cos(8*pi*x) },
#   function(x){ sin(10*pi*x) },
#   function(x){ cos(10*pi*x) }
# )

# define filter
theta <- function(omega,f){
2*f+
 1i*rev(f) +
 omega*cumsum(f)/length(f) +
 rank_one_tensor( function(x){sin(x)}, function(x){exp(x)}, f ) +
 kernel_operator( function(x,y){sin(omega+x+2*y)}, f )
}

# simulation setting
t_max <- 1000
n_grid <- 101

# simulate in the spectral domain
fts_x <- filter_simulate(theta, t_max, n_grid, sigma=sigma)

# # Alternatively simulate with the known eigendecomposition of sigma
# fts_x <- filter_simulate(theta, t_max, n_grid, sigma_eigenfunctions = sigma_eigenfunctions, sigma_eigenvalues=sigma_eigenvalues)

# plot the first curve
plot(fts_x[,1], type='l')

}
\references{
Rubin, Panaretos. \emph{Simulation of stationary functional time series with given spectral density}. arXiv, 2020
}
\seealso{
\code{\link{filter_covlagh_operator}} \code{\link{rank_one_tensor}} \code{\link{kernel_operator}}
}

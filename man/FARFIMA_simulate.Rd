% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FARFIMA_simulate.R
\name{FARFIMA_simulate}
\alias{FARFIMA_simulate}
\title{Simulate the FARFIMA(p,d,q) process in the spectral domain}
\usage{
FARFIMA_simulate(
  FARFIMA_pars,
  t_max,
  n_grid,
  seed_number = NULL,
  hybrid_ar = T,
  burnin = 100
)
}
\arguments{
\item{FARFIMA_pars}{The list of the parameters for the FARFIMA(p,d,q) process. Must contain fields: (i) \code{fractional_d}, a real number in the open interval (-0.5,0.5) controling the fractional integration degree. \code{fractional_d} being positive corresponds to long-rande dependence behaviour. (ii) \code{operators_ar}, the list of length 'p' the order of the autoregressive part. The autoregressive operators are considered to be integral operators defined through their kernels which are saved as the elements of the list \code{operators_ar} as functions of two variables, \code{x} and \code{y}, returning the value of the kernel at point (\code{x},\code{y}). In case of degenerate autoregressive part define \code{operators_ar} as an empty list. (iii) \code{operators_ma}, the list of length 'q', the order of the moving average part. Just like \code{operators_ar} its a liks of functions - the kernels of the moving average operators. (iv) The covariance opperator of the stochastic innovation process can be defined either through (iv-a) its kernel,  (iv-b) finite rank eigendecomposition, (iv-c) infinite rank decomposition. In the case (iv-a), define \code{sigma} as a function of two variables \code{x} and \code{y}, returning the value of the covariance kernel at point (\code{x},\code{y}). In the case (iv-b), define the elements \code{sigma_eigenvalues} as a vector of finitely many eigenvalues and \code{sigma_eigenfunctions} as a list of the same length as \code{sigma_eigenvalues} with each element being a function of variable \code{x} returning the value of that eigenfunction at point \code{x}. In the case (iv-c), define the elements \code{sigma_eigenvalues} as a function of the variable \code{n} returning the \code{n}-th eigenvalue and the element \code{sigma_eigenfunctions} as a function of two variables, \code{n} and \code{x}, returning the value of the \code{n}-th eigenfunctions at point \code{x}. See the example bellow for some examples on how to set up \code{FARFIMA_pars}.}

\item{t_max}{Time horizon to be simulated. Must be an even number, otherwise it is increased by one.}

\item{n_grid}{Number of grid points (spatial resolution) of the discretisation of [0,1] where the FTS is to be simulated.}

\item{seed_number}{The random seed inicialization for the simulation. The value \code{NULL} means no inicialization}

\item{hybrid_ar}{If set \code{TRUE} (default), the method first simulates the corresponding FARFIMA(0,d,q) process and then applies the autoregressive filter in the temporal domain. Such runtime is much faster than the fully spectral method (\code{hybrid_ar = FALSE}) in which case the method needs to solve a system of linear equation at each frequency.}

\item{burnin}{If hybrid_ar=TRUE set how long is the burn-in period for the autoregressive part (100 by default) in the temporal domain.}
}
\value{
functional time series sample, matrix of size (\code{n_grid},\code{t_max})
}
\description{
Simulate the FARFIMA(p,d,q) process, the functional autoregressive fractionally integrated moving average process.
}
\examples{
# (i) fractional integration
fractional_d <- 0 # in the open interval (-0.5, 0.5), positive number means long-range dependence

# (ii) autoregressive operators
operators_ar <- list(
function(x,y){ 0.3*sin(x-y) },
function(x,y){ 0.3*cos(x-y) },
function(x,y){ 0.3*sin(2*x) },
function(x,y){ 0.3*cos(y) }
)
# operators_ar <- list() # use empty list for degenerate AR part

# (iii) moving average kernels
# you can put here arbitrary long list of operators
operators_ma <- list(
function(x,y){ x+y },
function(x,y){ x },
function(x,y){ y }
)
# operators_ma <- list() # use empty list for degenerate MA part

# (iv-b) covariance of the inovation defined through eigenvalues and eigenfunctions
# you can put here arbitrary long lists but their lenghts should match
sigma_eigenvalues <- c(1, 0.6, 0.3, 0.1, 0.1, 0.1, 0.05, 0.05, 0.05, 0.05)
sigma_eigenfunctions <- list(
function(x){ sin(2*pi*x) },
function(x){ cos(2*pi*x) },
function(x){ sin(4*pi*x) },
function(x){ cos(4*pi*x) },
function(x){ sin(6*pi*x) },
function(x){ cos(6*pi*x) },
function(x){ sin(8*pi*x) },
function(x){ cos(8*pi*x) },
function(x){ sin(10*pi*x) },
function(x){ cos(10*pi*x) }
)

# # (iv-c) innovation covariance operator (Brownian motion)
# sigma_eigenvalues <- function(n) { 1/((n-0.5)*pi)^2 }
# sigma_eigenfunctions <- function(n,x) { sqrt(2)*sin((n-0.5)*pi*x) }

# put the parameters into one list
FARFIMA_pars <- list(fractional_d=fractional_d, operators_ar=operators_ar, operators_ma=operators_ma, sigma_eigenvalues=sigma_eigenvalues,sigma_eigenfunctions=sigma_eigenfunctions)

# # (iv-a) Alternatively, define the kernel of the white noise innovation.
# sigma <- function(x,y) { pmin(x,y) } # Brownian motion
# FARFIMA_pars <- list(fractional_d=fractional_d,operators_ar=operators_ar,operators_ma=operators_ma, sigma=sigma)


# simulate trajectory
if (FARFIMA_test_stationarity(FARFIMA_pars)){
 # fully spectral approach. if AR part is non-degenerate, the simulation involves solving a system of liear equations at each frequency
 fts_x <- FARFIMA_simulate(FARFIMA_pars, t_max, n_grid, hybrid_ar = F)
   
 # # hybrid simulation method
 # fts_x <- FARFIMA_simulate(FARFIMA_pars, t_max, n_grid, hybrid_ar = T)
   
 # display the first curve
 plot(fts_x[,1], type='l')
}

}
\references{
Rubin, Panaretos. \emph{Simulation of stationary functional time series with given spectral density}. arXiv, 2020
}
\seealso{
\code{\link{FARFIMA_covlagh_operator}} \code{\link{FARFIMA_test_stationarity}}
}
